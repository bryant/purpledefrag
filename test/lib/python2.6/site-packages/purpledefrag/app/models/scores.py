from psycopg2 import connect
from re import compile
from datetime import timedelta
import purpledefrag.app.g as g


class User(object):
	def __init__(self, name):
		self.name = name

	def exists(self):
		db = g.db
		c = db.cursor()

		c.execute("SELECT exists("
			"SELECT 1 FROM dfusers WHERE user = %(name)s"
			")", {"name":self.name})
		return c.fetchone()[0]

	def create(self, email):
		if self.exists():
			return False

class RunTime(object):
	def __init__(self, mapname, owner, runtime, promode,
		date = None, interference = 3, mode = 2):
		self.mapname = mapname
		self.owner = owner
		self.runtime = runtime
		self.promode = bool(promode)
		self.mode = mode
		self.date = date
		self.interference = interference

	def isValid(self):
		if self.interference != 3 or \
			seelf.mode in (5, 6 ,7):
			return False
		else:
			return True

'''class DefragRecords(object):
	table = "dfrecs"

	def __init__(self,database,user,max_runs_per_map = 5):
		self.c=connect(database=database,user=user)
		#self.r=self.c.cursor()
		self.cache={}
		self.max_runs_per_map = max_runs_per_map
	
	def __del__(self):
		#self.r.close()
		self.c.close()
	
	def insertRecord(self,record):
		# print 'insertrecord: %s'%record

		r = self.c.cursor()
		r.execute(
			"INSERT INTO %s (map, owner, runtime) \
			VALUES (%(map)s, %(owner)s, %(runtime)s)" % self.table,record
		)
		self.c.commit()
		r.close()
	
	def replaceRecord(self,old_id,record):
		# print 'replacerecord: %d, with %s'%(old_id,record)

		temp = dict(record,old_id = old_id)
		r = self.c.cursor()
		r.execute(
			"UPDATE dfrecs SET runtime = %(runtime)s,\
				owner = %(owner)s, date = NOW() \
			WHERE id = %(old_id)s",temp
		)
		self.c.commit()
		r.close()

	def tryRecord(self,record):
		r = self.c.cursor()
		r.execute(
			"SELECT id, runtime FROM dfrecs \
			WHERE owner = %(owner)s AND map = %(map)s \
			ORDER BY runtime ASC LIMIT 1",record
		)
		existing = r.fetchone()

		r.execute(
			"SELECT id, z.runtime FROM dfrecs INNER JOIN (\
				SELECT max(runtime) AS runtime FROM dfrecs WHERE map = %(map)s) AS z \
				ON dfrecs.runtime = z.runtime \
			WHERE map = %(map)s",record
		)
		slowest = r.fetchone()

		r.execute("SELECT count(1) FROM dfrecs WHERE map = %(map)s",record)
		num_records = r.fetchone()[0]

		r.close()

		if existing is not None:
			# only permit one top ten record per unique player name
			if record["runtime"] <= existing[1]:
				self.replaceRecord(existing[0],record)
		
		elif slowest is None or num_records < self.max_runs_per_map:
			# means that we're the first (and therefore fastest)
			self.insertRecord(record)

		elif record["runtime"] <= slowest[1]:
			self.replaceRecord(slowest[0],record)

		return self.topScores(record["map"],fresh=1)
	
	def topScores(self,map_name,fresh=0):
		if map_name not in self.cache or fresh==1:
			r = self.c.cursor()
			r.execute(
				"SELECT id, owner, runtime, date FROM dfrecs \
				WHERE map = %s \
				ORDER BY runtime ASC LIMIT %s",
				(map_name,self.max_runs_per_map)
			)
			
			self.cache[map_name]=r.fetchall()
			if len(self.cache[map_name]) == 0:
				self.cache[map_name] = None
			
			r.close()

		return self.cache[map_name]

raw_regex = compile("^ClientTimerStop: (?P<clientnum>[0-9]+) (?P<ms>[0-9]+) \
\"(?P<map>[^\"]+)\" \"(?P<owner>[^\"]*)\" (?P<gametype>[0-9\-]+) \
(?P<promode>[0-9]+) (?P<mode>[0-9\-]+) (?P<interference>[0-9]+) \
(?P<ob>[0-9]+) (?P<version>[0-9]+) (?P<date>[0-9\-]+)$")

def parseRawBroadcast(logline):
	match = raw_regex.match(logline)
	
	if match is not None:
		match = match.groupdict()

		for k in ("interference","mode","ms",
			"gametype","promode","ob"):

			match[k] = int(match[k])
		
		match["runtime"] = timedelta(milliseconds = match["ms"])

		return match
	
	else:
		return None

def isValidRecord(record_dict):
	if record_dict is None:
		return False
	
	if record_dict["interference"] != 3 or \
		record_dict["mode"] in (5,6,7):

		return False
	else:
		return True

def timedelta2str(d):
	hours,r = divmod(d.seconds,3600)
	minutes,seconds = divmod(r,60)
	milliseconds = d.microseconds/1000

	h,m,s = "","","%02d.%03d"%(seconds,milliseconds)
	if hours > 0:
		h = "%02d:"%hours
	if minutes > 0:
		m = "%02d:"%minutes

	return h+m+s


if __name__=="__main__":
	from sys import argv
	
	map_name=argv[1]
	print DefragRecords().topScore(map_name)'''
